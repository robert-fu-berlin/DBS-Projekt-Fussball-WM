diff --git a/src/active_record/ActiveRecordMapper.java 
b/src/active_record/ActiveRecordMapper.java index 75416ed..cc9084b 
100644 --- a/src/active_record/ActiveRecordMapper.java +++ 
b/src/active_record/ActiveRecordMapper.java @@ -81,6 +81,13 @@ public 
class ActiveRecordMapper {
 		return new ConcreteMonoFinder<A>(this, mapper);
 	}
 	
+ public <A extends ActiveRecord> ConcreteMultiFinder<A> 
findAll(Class<A> activeRecord) { + register(activeRecord); + + 
ClassMapper<A> mapper = (ClassMapper<A>) classMapper.get(activeRecord); 
+ return new ConcreteMultiFinder<A>(this, mapper); + } +
 	Connection obtainConnection() throws SQLException {
 		Connection newConnection = 
DriverManager.getConnection(url, user, password);
 		return newConnection; diff --git 
a/src/active_record/ClassMapper.java 
b/src/active_record/ClassMapper.java index 8915bcb..5a60522 100644 --- 
a/src/active_record/ClassMapper.java +++ 
b/src/active_record/ClassMapper.java @@ -16,8 +16,6 @@ import 
java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
 
-import apple.laf.CoreUIConstants.State; -
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.Lists; @@ -25,6 +23,8 @@ import 
com.google.common.collect.ImmutableBiMap.Builder;
 
 class ClassMapper<A extends ActiveRecord> {
 
+ //TODO: add bimap mapping column names to member names and back +
 	private final String tablename;
 	
 	private final ImmutableBiMap<String, Field> columnMap; @@ 
-312,40 +312,75 @@ class ClassMapper<A extends ActiveRecord> {
 	 * Returns the results of a select query using the given 
parameters in the where clause, e.g.
 	 * <code>SELECT * FROM Table WHERE fields.get(0) 
relations.get(0) values.get(0) && fields.get(1) ï¿½</code>
 	 * where relations.get(0) is one of the binary relations 
specified in {@link Relation}. + * The results can be ordered optionally 
by setting "orderByFields" to a non null list of field values.
 	 *
 	 * @param fields
 	 * @param relations
 	 * @param values + * @param orderByFields + * @param 
ascendingValues
 	 * @return
 	 * @throws SQLException
 	 */ - public List<A> runQueryWithParameters(Connection 
connection, List<String> fields, List<Relation> relations, List<Object> 
values) throws SQLException { + public List<A> 
runQueryWithParameters(Connection connection, List<String> fields, 
List<Relation> relations, List<Object> values, List<String> 
orderByFields, List<Boolean> ascendingValues) throws SQLException {
 		if (fields.size() != relations.size() || 
relations.size() != values.size() || values.size() != fields.size())
 			throw new IllegalArgumentException(); // TODO 
find useful detail message
 		
- StringBuffer buffer = new StringBuffer(); - for (int i = 0; i < 
fields.size(); i++) { - buffer.append(javaToUnderscore(fields.get(i))); 
- buffer.append(" "); - buffer.append(relations.get(i)); - 
buffer.append(" "); - 
buffer.append(TypeMapper.postgresify(values.get(i))); - - if (i < 
fields.size() - 1) - buffer.append(" and "); + for (String field : 
fields) { + if (!columnMap.containsKey(javaToUnderscore(field))) + throw 
new IllegalArgumentException("Field " + field + " is not a member of " + 
mappedClass.getSimpleName());
 		}
 		
+ for (String field : orderByFields) { + if 
(!columnMap.containsKey(javaToUnderscore(field))) + throw new 
IllegalArgumentException("Field " + field + " is not a member of " + 
mappedClass.getSimpleName()); + } + + StringBuffer buffer = new 
StringBuffer(); + + if (!fields.isEmpty()) { + buffer.append(" where "); 
+ for (int i = 0; i < fields.size(); i++) { + 
buffer.append(javaToUnderscore(fields.get(i))); + buffer.append(" "); + 
buffer.append(relations.get(i)); + buffer.append(" "); + 
buffer.append(TypeMapper.postgresify(values.get(i))); + + if (i < 
fields.size() - 1) + buffer.append(" and "); + } + } else + 
buffer.append(" "); //XXX +
 		List<String> columnNames = new 
ArrayList<String>(columnMap.keySet());
 		
- String sql = "Select " + Joiner.on(",").join(columnNames) + " from " + 
tablename + " where " + buffer.toString() + ";"; + if 
(!orderByFields.isEmpty()) { + buffer.append("order by "); + for (int i 
= 0; i<orderByFields.size(); i++) { + 
buffer.append(javaToUnderscore(orderByFields.get(i))); + if 
(ascendingValues.get(i)) + buffer.append(" asc"); + else + 
buffer.append(" desc"); + if (i < orderByFields.size()-1) + 
buffer.append(" ,"); + } + }
 		
- Statement statement = connection.createStatement(); + String sql = 
"Select " + Joiner.on(",").join(columnNames) + " from " + tablename + 
buffer.toString() + ";";
 		
+ Statement statement = connection.createStatement(); +
 		ResultSet resultSet = statement.executeQuery(sql);
 		
 		return fromResultSet(resultSet);
 	}
 	
+ public List<A> runQueryWithParameters(Connection connection, 
List<String> fields, List<Relation> relations, List<Object> values) 
throws SQLException { + return runQueryWithParameters(connection, 
fields, relations, values, Collections.EMPTY_LIST, 
Collections.EMPTY_LIST); + } +
 	private static String javaToUnderscore(String string) {
 		StringBuffer result = new StringBuffer();
 		
diff --git a/src/active_record/ConcreteMonoFinder.java 
b/src/active_record/ConcreteMonoFinder.java index a00bb2c..1a6a636 
100644 --- a/src/active_record/ConcreteMonoFinder.java +++ 
b/src/active_record/ConcreteMonoFinder.java @@ -5,6 +5,9 @@ import 
java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
 
+import com.google.common.collect.ImmutableBiMap; +import 
com.google.common.collect.ImmutableList; +
 import active_record.finder.InitialMonoFinder;
 import active_record.finder.MonoFinder;
 import active_record.finder.MonoNeedsValue; diff --git 
a/src/active_record/finder/InitialMultiFinder.java 
b/src/active_record/finder/InitialMultiFinder.java deleted file mode 
100644 index dc5cbd1..0000000 --- 
a/src/active_record/finder/InitialMultiFinder.java +++ /dev/null @@ -1,9 
+0,0 @@ -package active_record.finder; - -import 
active_record.ActiveRecord; - -public interface InitialMultiFinder<T 
extends ActiveRecord> { - - MultiNeedsValue<T> where(String field); - -} 
diff --git a/src/active_record/finder/MultiFinder.java 
b/src/active_record/finder/MultiFinder.java index 72c9500..9f1ea87 
100644 --- a/src/active_record/finder/MultiFinder.java +++ 
b/src/active_record/finder/MultiFinder.java @@ -4,8 +4,12 @@ import 
java.util.List;
 
 import active_record.ActiveRecord;
 
-public interface MultiFinder<T extends ActiveRecord> extends 
InitialMonoFinder<T> { +public interface MultiFinder<T extends 
ActiveRecord> {
 
 	List<T> please();
 	
+ MultiNeedsValue<T> where(String field); + + MultiFinder<T> 
orderBy(String field, boolean ascending); +
 }
diff --git a/src/dbs_fussball/Main.java b/src/dbs_fussball/Main.java 
index e14d8c5..1b123ff 100644 --- a/src/dbs_fussball/Main.java +++ 
b/src/dbs_fussball/Main.java @@ -23,7 +23,7 @@ public class Main {
 		classes.add(Stadium.class);
 		classes.add(Team.class);
 
- ActiveRecordMapper arm = new ActiveRecordMapper("dbs_fussball", 
"postgres", "vuvzela", "dbs"); + ActiveRecordMapper arm = new 
ActiveRecordMapper("dbs_fussball", "postgres", "vuvuzela", "dbs");
 		// Setup tables
 		for (Class<? extends ActiveRecord> activeRecord : 
classes) {
 			// Drop existing tables diff --git 
a/src/dbs_fussball/test/ActiveRecordMapperTest.java 
b/src/dbs_fussball/test/ActiveRecordMapperTest.java index 
736cb98..c45cbaf 100644 --- 
a/src/dbs_fussball/test/ActiveRecordMapperTest.java +++ 
b/src/dbs_fussball/test/ActiveRecordMapperTest.java @@ -3,6 +3,11 @@ 
package dbs_fussball.test;
 import static org.junit.Assert.fail;
 
 import java.sql.SQLException; +import java.util.ArrayList; +import 
java.util.Arrays; +import java.util.List; +import java.util.Set; +import 
java.util.HashSet;
 
 import junit.framework.Assert;
 
@@ -18,34 +23,24 @@ import dbs_fussball.model.Person;
 public class ActiveRecordMapperTest {
 
 	private ActiveRecordMapper arm; -	private Person podolski;
 	
- @BeforeClass - public static void setUpBeforeClass() throws Exception 
{ - ActiveRecordMapper arm = new ActiveRecordMapper("dbs_fussball", 
"postgres", "vuvuzela", "test"); - arm.createTable(Person.class); -	
}
- - @AfterClass - public static void tearDownAfterClass() throws 
Exception { - ActiveRecordMapper arm = new 
ActiveRecordMapper("dbs_fussball", "postgres", "vuvuzela", "test"); - 
arm.dropTable(Person.class); -	}
 
 	@Before
 	public void setUp() throws Exception { + ActiveRecordMapper arm 
= new ActiveRecordMapper("dbs_fussball", "postgres", "vuvuzela", 
"test"); + arm.createTable(Person.class);
 		this.arm = new ActiveRecordMapper("dbs_fussball", 
"postgres", "vuvuzela", "test"); - podolski = new Person("Lukas", 
"Podolski"); - arm.save(podolski);
 	}
 
 	@After
 	public void tearDown() throws Exception { - 
arm.delete(podolski); + arm.dropTable(Person.class);
 	}
 
 	@Test
 	public void testFindBy() throws Exception { + Person podolski = 
new Person("Lukas", "Podolski"); + arm.save(podolski);
 		Long podolksiId = new Long(podolski.getId());
 			
 		Person maybePodolksi = arm.findBy(Person.class, 
podolksiId); @@ -55,9 +50,59 @@ public class ActiveRecordMapperTest {
 
 	@Test
 	public void testFind() throws Exception { + Person podolski = 
new Person("Lukas", "Podolski"); + arm.save(podolski);
 		Person maybePodolksi = 
arm.find(Person.class).where("firstName").is("Lukas").where("lastName").is("Podolski").please(); 
-
 		Assert.assertEquals(podolski, maybePodolksi);
 	}
 
+ @Test + public void testFindAll() throws Exception { + Person gomez = 
new Person("Mario", "Gomez"); + gomez.setStageName("Majo"); + Person 
ronaldoC = new Person("Christiano", "Ronaldo"); + Person ronaldoL = new 
Person("Ronaldo" ,"Luis Nazario"); + Person ronaldoG = new 
Person("Ronaldo" ,"Gueario"); + Person ronaldoM = new Person("Ronaldo" 
,"Maczinski"); + Person ronaldoCe = new Person("Ronaldo" ,"Cerritos"); + 
arm.save(gomez); + arm.save(ronaldoC); + arm.save(ronaldoCe); + 
arm.save(ronaldoL); + arm.save(ronaldoG); + arm.save(ronaldoM); + 
Set<Person> trueRonaldos = new HashSet<Person>(); + 
trueRonaldos.add(ronaldoCe); + trueRonaldos.add(ronaldoL); + 
trueRonaldos.add(ronaldoG); + trueRonaldos.add(ronaldoM); + Set<Person> 
maybeRonaldos = new 
HashSet<Person>(arm.findAll(Person.class).where("firstName").is("Ronaldo").please()); 
+ Assert.assertEquals(trueRonaldos, maybeRonaldos); + } + + @Test + 
public void testOrderBy() throws Exception { + Person az = new 
Person("a", "z"); + Person by = new Person("b" ,"y"); + Person cx = new 
Person("c" ,"x"); + Person dw = new Person("d" ,"w"); + Person ev = new 
Person("e" ,"v"); + Person cacau = new Person("Cacau"); + 
arm.save(cacau); + arm.save(dw); + arm.save(by); + arm.save(cx); + 
arm.save(ev); + arm.save(az); + List<Person> alphabeticallyByFirst = new 
ArrayList<Person>(); + alphabeticallyByFirst.add(az); + 
alphabeticallyByFirst.add(by); + alphabeticallyByFirst.add(cx); + 
alphabeticallyByFirst.add(dw); + alphabeticallyByFirst.add(ev); + 
alphabeticallyByFirst.add(cacau); + List<Person> 
maybeAlphabeticallyByFirst = new ArrayList<Person>(); + 
maybeAlphabeticallyByFirst = 
arm.findAll(Person.class).orderBy("firstName", true).please(); + 
Assert.assertEquals(alphabeticallyByFirst, maybeAlphabeticallyByFirst); 
+	}
 }
